---
title: "R Notebook"
output: html_notebook
---

```{r}
library(readr)
CSV_for_ConditionsStandardConditions_YeastStrainWildType_Plate_24423 <- read_csv("~/repo/CurveAnalysis/CSVFiles/CSV_for_ConditionsStandardConditions,YeastStrainWildType_Plate_24423.csv")
current.data<-CSV_for_ConditionsStandardConditions_YeastStrainWildType_Plate_24423
current.data[grep("X",names(current.data))]<-NULL
current.data
log.od<-log(t(as.matrix(current.data[,-1])))
matplot(log.od,type="l")
dim(log.od)
time<-as.numeric(colnames(current.data[-1]))
rates<-apply(log.od,MARGIN = 2,FUN=function(x)diff(x)/diff(time))
matplot(rates,type="l")
plot(rowMeans(rates),type="l")
abline(h=0)
current.data<-as.data.frame(current.data)
colnames(current.data[,-1])<-1:130
#reshape data for lmer
tmp2<-reshape(data=current.data,direction = "long",varying=colnames(current.data[,-1]),v.names ="OD" ,timevar = "Time",times =time)
#Wrapper for Mixed effects model with variable break point
foo <- function(bp)
{
  mod <- lmer(LogOD ~ b1(Time, bp) + b2(Time, bp) + (b1(Time, bp) + b2(Time, bp) | Well), data = tmp2)
  deviance(mod,REML=FALSE)
}


N <- 40 # number of sampled points
K <- 3  # number of knots

piece.formula <- function(var.name, knots) {
  formula.sign <- rep(" - ", length(knots))
  formula.sign[knots < 0] <- " + "
  paste(var.name, "+",
        paste("I(pmax(", var.name, formula.sign, abs(knots), ", 0))",
              collapse = " + ", sep=""))
}
library(lme4)
library(bcp)
plot(bcp(log.od))
knots<-time[c(20,50,100)]
#model <- lmer(formula=formula(paste("log(OD) ~",paste( piece.formula("Time", knots),"+1|Well_Name"))),data = tmp2 )
 rand.slope<-paste("(1+",paste(piece.formula("Time", knots),")|Well_Name"))
model <- lmer(formula=formula(paste("log(OD) ~1+",rand.slope)),data = tmp2 )
```

No with stan

```{r}

#time[1]=0
#OD<-as.matrix(current.data[,-1])
M <- ceiling(length(time)^(2/3))
#M<-10
N <- 16
K=2
#OD<-as.matrix(current.data[1:N,-1])
T<- length(time)


#timeN<--1*normalize.interval(time)

OD.old<-OD
```

```{r}
library(rstan)
library(coda)
library(ggmcmc)
library(bcp)
set.seed(123)
#prior<-matrix(,N,P)
#P=16;
#for(i in 1:N){
#  p<- bcp(OD[i,],time)
#  prior[i,]<-sort(order(p$posterior.prob,decreasing = T)[1:P])
#}

#prior<-c(10:16,prior[2:length(prior)])
#prior<-c(26,41)
#prior<-c(1:26,prior[3:length(prior)])
#P<-length(prior)
N=16
M=16
MAXT=max(time)
X<-bernstein.matrix(M,time,a=time[1],b=time[length(time)])
D<-bernstein.derivative.operator(M)
subdiv<-0.5

Q<-subdivision.matrix(subdiv,M)
L<-which(timeN<=subdiv)
L<-L[length(L)]
Xs<-bernstein.matrix(M,time[1:L],a=time[1],b=time[L])
Xa<-bernstein.matrix(M,time[L:T],a=time[L],b=time[length(time)])
Id<-bernstein.integral.operator(M)
OD<-OD.old[1:N,]
#OD<-t(scale(t(OD)))
#MIN=min(log(OD))
#MAX=max(log(OD))
MIN=0
MAX=max(OD)+0.1
#LAMBDA=20
#SIGMA_MU=0.01
SIGMA_MU=0.1
K0=0.01
#MU=c(0.2,0.06)
MU=c(0,0,0)
LAMBDA=0.01
SIGMA_A=0.1
#timeN <- as.numeric(colnames(OD.old))
#timeN[1] <- 0
#timeN<--1*normalize.interval(timeN)
T <- length(timeN)
model <- stan_model(file = "BernsteinFitDynamicIntegral.stan")
rstan_options(auto_write = TRUE)
options(mc.cores = parallel::detectCores())
#fit<-stan("BernsteinFitDynamicForm2.stan",chains=6,iter = 3000)
fit<-vb(model, output_samples=1000, seed=123)
#fitrstan::optimizing()
s <- mcmc.list(lapply(1:ncol(fit), function(x) mcmc(as.array(fit)[,x,])))

S <- ggs(s)

ggs_caterpillar(S,family = "rate")
ggs_caterpillar(S,family = "sigma")
ggs_caterpillar(S,family="MU")
ggs_caterpillar(S,family="lambda")
#gs_caterpillar(S,family="intercept")
#ggs_geweke(S)
#ggs_caterpillar(S,family = "DA_coef")
#ggs_caterpillar(S,family = "^A_coef")
#ggs_caterpillar(S,family = "lp")
#ggs_caterpillar(S,family="intercept")

#plotfit(fit)
#save(list="fit",file="fitADVI.RData")
#matplot(t(OD),type="l")
#tmp<-rstan::extract(fit,"rate")
#rate<-tmp$rate

#t2<-t(matrix(colMeans(rate),N,3))
#boxplot(t(t2),type="l")

tmp<-rstan::extract(fit,"OD_pred")
ODp<-tmp$OD_pred
#plot(colMeans(ODp))
ODp<-t(matrix(colMeans(ODp),N,T))
matplot(ODp,type="l",ylim=c(0,0.9))
#matplot(t(OD),type="l",ylim=c(0,0.9))

tmp<-rstan::extract(fit,"DOD_pred")
DODp<-tmp$DOD_pred
#plot(colMeans(DODp)/colMeans(ODp))
DODp<-t(matrix(colMeans(DODp),N,T))
matplot(DODp,type="l")
matplot(DODp/ODp,type="l",main="loss posterior")
tmp<-rstan::extract(fit,"loss")
lossp<-tmp$loss
lossp<-t(matrix(colMeans(lossp),N,T))
matplot(lossp,type="l",title="loss")
abline(h=0)
#lines(diff(ODp[,2]/diff(timeN)))

#plot(diff(ODp[,2]/(65*diff(timeN))))
#plot(diff(OD[2,])/diff(time))

#matplot(t(log(OD))-MIN,type="l")


#rate<-(matrix(colMeans(rate),N,2))
#boxplot(rate,main="mean rates")
#plot(colMeans(rate[,1,1]))
```



```{r}
library(rstan)
library(coda)
library(ggmcmc)
rstan_options(auto_write = TRUE)
options(mc.cores = parallel::detectCores())
fit<-stan("BernsteinFit.stan",chains=6 )
save(list="fit",file="fit.RData")
s <- mcmc.list(lapply(1:ncol(fit), function(x) mcmc(as.array(fit)[,x,])))

S <- ggs(s)

ggs_caterpillar(S,family = "rate")
ggs_caterpillar(S,family = "sigma")
ggs_caterpillar(S,family = "DA_coef")
ggs_caterpillar(S,family = "^A_coef")
#ggs_caterpillar(S,family = "lp")
#ggs_caterpillar(S,family="intercept")

#plotfit(fit)
#matplot(t(OD),type="l")
#tmp<-rstan::extract(fit,"rate")
#rate<-tmp$rate

#t2<-t(matrix(colMeans(rate),N,3))
#boxplot(t(t2),type="l")

tmp<-rstan::extract(fit,"OD_pred")
ODp<-tmp$OD_pred

ODp<-t(matrix(colMeans(ODp),N,T))
matplot(ODp,type="l",ylim=c(0,0.9))
matplot(t(OD),type="l",ylim=c(0,0.9))

tmp<-rstan::extract(fit,"DOD_pred")
DODp<-tmp$DOD_pred

DODp<-t(matrix(colMeans(DODp),N,T))
matplot(DODp/ODp,type="l")
abline(h=0)
```

